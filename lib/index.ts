import qs from 'querystring';
import axios from 'axios';
import crypto from 'crypto';

/**
 * Yubico Validation Protocol v2.0
 * https://developers.yubico.com/yubikey-val/Validation_Protocol_V2.0.html
 */

/**
 * Map of responses from the Yubikey API server.
 */
const Status: Map<string, string> = new Map([
  ['OK', 'The OTP is valid.'],
  ['BAD_OTP', 'The OTP is invalid format.'],
  ['REPLAYED_OTP', 'The OTP has already been seen by the service.'],
  ['BAD_SIGNATURE', 'The HMAC signature verification failed.'],
  ['MISSING_PARAMETER', 'The request lacks a parameter.'],
  ['NO_SUCH_CLIENT', 'The request id does not exist.'],
  ['OPERATION_NOT_ALLOWED', 'The request id is not allowed to verify OTPs.'],
  ['BACKEND_ERROR', 'Unexpected error in our server. Please contact Yubico if you see this error.'],
  ['NOT_ENOUGH_ANSWERS', 'Server could not get requested number of syncs before timeout.'],
  ['REPLAYED_REQUEST', 'Server has seen the OTP/Nonce combination before.']
]);

/**
 * Parameters to send to the Yubico API server.
 */
class YubikeyRequest {
  [key: string]: string;

  constructor(
    public nonce: string,
    public otp: string,
    public id: string
  ) {}
}

/**
 * Options for the Yubikey verification request.
 *
 * @todo
 * @export
 * @class YubikeyOptions
 */
export interface YubikeyOptions {
  [key: string]: any;
  timestamp?: number;
  sl?: string;
  timeout?: number;
}

export interface YubikeyResponse {
  otp: string;
  nonce: string;
  h: string;
  t: string;
  status: string;
  timestamp: string;
  sessioncounter?: string;
  sessionuse?: string;
  sl?: number;
}

/**
 * Yubikey verification class.
 *
 * @export
 * @class Yubikey
 */
export class Yubikey {
  private clientId;
  private clientSecret;

  /**
   * Class constructor
   * @param clientId Client ID for the API request.
   * @param clientSecret Client secret for the API request.
   */
  constructor(
    clientId?: string,
    clientSecret?: string
  ) {
    this.clientId = clientId || process.env.YUBIKEY_CLIENT_ID;
    this.clientSecret = clientSecret || process.env.YUBIKEY_CLIENT_SECRET;
  }

  /**
   * Verification of a Yubikey OTP by the Yubico API.
   * @param otp One-time password generated by a Yubikey.
   * @param options Additional options for the request.
   * @returns
   */
  public async verify(otp: string, options?: YubikeyOptions): Promise<YubikeyResponse> {
    const nonce: string = await new Promise((resolve, reject) => {
      crypto.randomBytes(40, (err, buf) => {
        if(err) reject(err);
        return resolve(buf.toString('hex').slice(0, 40));
      });
    });

    if(!this.clientId) {
      throw new Error("Client ID was not specified");
    }

    if(!this.clientSecret) {
      throw new Error("Client secret was not specified");
    }

    const params: YubikeyRequest = new YubikeyRequest(
      nonce,
      otp,
      this.clientId
    );

    if(options) {
      for(const option in options) {
        Object.defineProperty(params, option, {
          value: options[option],
          enumerable: true
        })
      }
    }

    const signature = this.generateSignature(params);

    Object.defineProperty(params, 'h', {
      value: signature,
      enumerable: true
    });

    const query = this.querify(params, true);

    const uri = `https://api.yubico.com/wsapi/2.0/verify?${query}`;

    let response = await axios.get(uri);

    if(response.status != 200) {
      throw new Error(`Yubico server returned error ${response.status}: ${response.statusText}`);
    }

    response.data = this.parseResponseBody(response.data);

    const signatureServer = response.data.h;

    delete response.data.h;

    if(response.data.status !== 'OK') {
      throw new Error(`Yubico server responded with error: ${Status.get(response.data.status)}`);
    }

    if(response.data.otp !== params.otp) {
      throw new Error('Response OTP does not match request OTP');
    }

    if(response.data.nonce !== params.nonce) {
      throw new Error('Response nonce does not match request nonce');
    }

    if(this.generateSignature(response.data) !== signatureServer) {
      throw new Error('Response signature is invalid');
    }

    return response.data;
  }

  /**
   * Generate a HMAC signature for the request.
   * @param params The parameters of the request.
   * @returns An HMAC signature of the parameters.
   */
  private generateSignature(params: YubikeyRequest): string {
    if(this.clientSecret) {
      const buf = Buffer.from(this.clientSecret, 'base64');

      const hmac = crypto.createHmac('sha1', buf);

      return hmac.update(this.querify(params)).digest('base64')
    } else {
      throw new Error('Failed to generate HMAC signature');
    }
  }

  /**
   * Convert a string body response to a valid JSON Object
   *
   * @param body The string response body
   * @returns A JSON object of key-value pairs
   */
  private parseResponseBody(body: string): any {
    let params = {};

    body.trim()
      .split('\n')
      .forEach((line: string) => {
        const match = line.trim().match(/^(\w+)=(.*)$/);

        if(match) {
          Object.defineProperty(params, match[1], {
            value: match[2],
            enumerable: true
          });
        }
      });

    return params;
  }

  /**
   * Creates a valid query string from the input request parameters,
   * escaping HTML entities as needed.
   * @param params The request parameters
   * @param escape Whether to escape HTML entities
   * @returns A stringified representation of the request query
   */
  private querify(params: YubikeyRequest, escape: boolean = false): string {
    return Object.keys(params)
      .sort()
      .map((key: string) => {
        if(escape){
          let d = {};
          Object.defineProperty(d, key, {
            value: params[key],
             enumerable: true
          });
          return qs.stringify(d);
        } else {
          return `${key}=${params[key]}`;
        }
      })
      .join('&');
  }
}
